#!/usr/bin/env bash
#
# mu - Multi-Utility Script
# A collection of useful utilities with friendly output
# Compatible with macOS (Darwin) and Linux
#
# Usage: mu <command> [options]
#
# Commands:
#   clone    Clone repositories from a list of links with rate limiting
#   help     Show this help message
#

set -euo pipefail

#--------------------------------------------------------------------------------------------------
# Constants
#--------------------------------------------------------------------------------------------------

readonly VERSION="0.1.0"
readonly SCRIPT_NAME="mu"

# Default values
readonly DEFAULT_DELAY=2          # seconds between clones
readonly DEFAULT_OUTPUT_DIR="."   # current directory

#--------------------------------------------------------------------------------------------------
# Colors & Styling
#--------------------------------------------------------------------------------------------------

# Check if terminal supports colors
if [[ -t 1 ]] && command -v tput &>/dev/null && [[ $(tput colors 2>/dev/null || echo 0) -ge 8 ]]; then
    readonly COLOR_RESET="\033[0m"
    readonly COLOR_BOLD="\033[1m"
    readonly COLOR_DIM="\033[2m"
    readonly COLOR_RED="\033[31m"
    readonly COLOR_GREEN="\033[32m"
    readonly COLOR_YELLOW="\033[33m"
    readonly COLOR_BLUE="\033[34m"
    readonly COLOR_MAGENTA="\033[35m"
    readonly COLOR_CYAN="\033[36m"
    readonly COLOR_WHITE="\033[37m"
else
    readonly COLOR_RESET=""
    readonly COLOR_BOLD=""
    readonly COLOR_DIM=""
    readonly COLOR_RED=""
    readonly COLOR_GREEN=""
    readonly COLOR_YELLOW=""
    readonly COLOR_BLUE=""
    readonly COLOR_MAGENTA=""
    readonly COLOR_CYAN=""
    readonly COLOR_WHITE=""
fi

#--------------------------------------------------------------------------------------------------
# Output Helpers
#--------------------------------------------------------------------------------------------------

# Print styled header
print_header() {
    echo -e "\n${COLOR_BOLD}${COLOR_BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${COLOR_RESET}"
    echo -e "${COLOR_BOLD}${COLOR_BLUE}  $1${COLOR_RESET}"
    echo -e "${COLOR_BOLD}${COLOR_BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${COLOR_RESET}\n"
}

# Print info message
info() {
    echo -e "${COLOR_CYAN}ℹ${COLOR_RESET}  $1"
}

# Print success message
success() {
    echo -e "${COLOR_GREEN}✓${COLOR_RESET}  $1"
}

# Print warning message
warn() {
    echo -e "${COLOR_YELLOW}⚠${COLOR_RESET}  $1"
}

# Print error message
error() {
    echo -e "${COLOR_RED}✗${COLOR_RESET}  $1" >&2
}

# Print progress indicator
progress() {
    echo -e "${COLOR_MAGENTA}→${COLOR_RESET}  $1"
}

# Print dim/secondary text
dim() {
    echo -e "${COLOR_DIM}   $1${COLOR_RESET}"
}

# Print a separator line
separator() {
    echo -e "${COLOR_DIM}──────────────────────────────────────────────────────────${COLOR_RESET}"
}

# Print a progress bar
# Usage: progress_bar <current> <total> <width>
progress_bar() {
    local current="$1"
    local total="$2"
    local width="${3:-40}"
    local percent=$((current * 100 / total))
    local filled=$((current * width / total))
    local empty=$((width - filled))

    # Build the bar
    local bar=""
    for ((i = 0; i < filled; i++)); do bar+="█"; done
    for ((i = 0; i < empty; i++)); do bar+="░"; done

    # Print with carriage return for in-place update
    printf "\r  ${COLOR_CYAN}[${COLOR_GREEN}%s${COLOR_DIM}%s${COLOR_CYAN}]${COLOR_RESET} ${COLOR_BOLD}%3d%%${COLOR_RESET} (%d/%d)" \
        "$(printf '%*s' "$filled" '' | tr ' ' '█')" \
        "$(printf '%*s' "$empty" '' | tr ' ' '░')" \
        "$percent" "$current" "$total"
}

#--------------------------------------------------------------------------------------------------
# Utility Functions
#--------------------------------------------------------------------------------------------------

# Cross-platform sleep that works on both macOS and Linux
# Supports fractional seconds
portable_sleep() {
    local seconds="$1"

    if command -v perl &>/dev/null; then
        perl -e "select(undef, undef, undef, $seconds)"
    else
        # Fallback to regular sleep (may not support fractions on older systems)
        sleep "$seconds"
    fi
}

# Extract the base repository URL from a GitHub link
# Handles: /tree/branch/path, /blob/branch/path, direct repo links
extract_repo_url() {
    local url="$1"

    # Remove trailing slashes
    url="${url%/}"

    # Check if it's a GitHub URL
    if [[ "$url" =~ ^https?://github\.com/([^/]+)/([^/]+) ]]; then
        local owner="${BASH_REMATCH[1]}"
        local repo="${BASH_REMATCH[2]}"

        # Remove .git suffix if present for matching, add back later
        repo="${repo%.git}"

        # Return the clean repo URL
        echo "https://github.com/${owner}/${repo}.git"
        return 0
    fi

    # Check if it's a GitLab URL (similar structure)
    if [[ "$url" =~ ^https?://gitlab\.com/([^/]+)/([^/]+) ]]; then
        local owner="${BASH_REMATCH[1]}"
        local repo="${BASH_REMATCH[2]}"
        repo="${repo%.git}"
        echo "https://gitlab.com/${owner}/${repo}.git"
        return 0
    fi

    # For other git URLs, return as-is (assuming they're valid)
    if [[ "$url" =~ \.git$ ]] || [[ "$url" =~ ^git@ ]]; then
        echo "$url"
        return 0
    fi

    # Return empty for non-git URLs
    echo ""
    return 1
}

# Get owner/org from URL (e.g., "awslabs" from github.com/awslabs/mcp)
get_repo_owner() {
    local url="$1"

    if [[ "$url" =~ ^https?://github\.com/([^/]+)/([^/]+) ]]; then
        echo "${BASH_REMATCH[1]}"
        return 0
    fi

    if [[ "$url" =~ ^https?://gitlab\.com/([^/]+)/([^/]+) ]]; then
        echo "${BASH_REMATCH[1]}"
        return 0
    fi

    # For other URLs, return empty
    echo ""
}

# Get repository name from URL
get_repo_name() {
    local url="$1"
    local repo_url

    repo_url=$(extract_repo_url "$url") || return 1

    # Extract repo name from URL
    local name
    name=$(basename "$repo_url" .git)
    echo "$name"
}

# Check if a directory exists and is a git repo
is_git_repo() {
    local dir="$1"
    [[ -d "$dir/.git" ]]
}

#--------------------------------------------------------------------------------------------------
# Command: clone
#--------------------------------------------------------------------------------------------------

clone_usage() {
    echo -e "${COLOR_BOLD}Usage:${COLOR_RESET} $SCRIPT_NAME clone [options] <links-file>

Clone git repositories from a list of URLs with rate limiting.

${COLOR_BOLD}Arguments:${COLOR_RESET}
  <links-file>          File containing repository URLs (one per line)

${COLOR_BOLD}Options:${COLOR_RESET}
  -d, --delay <secs>    Delay between clones (default: ${DEFAULT_DELAY}s)
  -o, --output <dir>    Output directory for clones (default: current dir)
  -s, --shallow         Perform shallow clones (--depth 1 --single-branch)
  -n, --dry-run         Show what would be cloned without cloning
  -q, --quiet           Minimal output (progress bar only)
  -h, --help            Show this help message

${COLOR_BOLD}Features:${COLOR_RESET}
  • Pre-scans links to show statistics before cloning
  • Shows git clone progress for each repository
  • Clean Ctrl+C handling with partial progress summary
  • Only clones primary branch (--single-branch)
  • Automatically extracts repo URLs from GitHub file/folder links
  • Skips already cloned repositories, duplicates, and non-git URLs

${COLOR_BOLD}Examples:${COLOR_RESET}
  $SCRIPT_NAME clone links.txt
  $SCRIPT_NAME clone -d 5 -o ./repos links.txt
  $SCRIPT_NAME clone --shallow --quiet links.txt
"
}

cmd_clone() {
    local links_file=""
    local delay="$DEFAULT_DELAY"
    local output_dir="$DEFAULT_OUTPUT_DIR"
    local shallow=false
    local dry_run=false
    local quiet=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d|--delay)
                delay="$2"
                shift 2
                ;;
            -o|--output)
                output_dir="$2"
                shift 2
                ;;
            -s|--shallow)
                shallow=true
                shift
                ;;
            -n|--dry-run)
                dry_run=true
                shift
                ;;
            -q|--quiet)
                quiet=true
                shift
                ;;
            -h|--help)
                clone_usage
                return 0
                ;;
            -*)
                error "Unknown option: $1"
                clone_usage
                return 1
                ;;
            *)
                if [[ -z "$links_file" ]]; then
                    links_file="$1"
                else
                    error "Unexpected argument: $1"
                    clone_usage
                    return 1
                fi
                shift
                ;;
        esac
    done

    # Validate arguments
    if [[ -z "$links_file" ]]; then
        error "Missing required argument: <links-file>"
        echo ""
        clone_usage
        return 1
    fi

    if [[ ! -f "$links_file" ]]; then
        error "File not found: $links_file"
        return 1
    fi

    # Create temp files for processing (bash 3.x compatible)
    local processed_file repos_file
    processed_file=$(mktemp)
    repos_file=$(mktemp)
    trap "rm -f '$processed_file' '$repos_file'" EXIT

    # ─────────────────────────────────────────────────────────────────────────
    # Phase 1: Pre-scan to analyze links and build clone list
    # ─────────────────────────────────────────────────────────────────────────

    $quiet || info "Scanning links file..."

    local total_urls=0
    local skipped_invalid=0
    local skipped_duplicate=0
    local skipped_existing=0

    while IFS= read -r url || [[ -n "$url" ]]; do
        # Skip empty lines and comments
        [[ -z "$url" ]] && continue
        [[ "$url" =~ ^[[:space:]]*# ]] && continue

        # Trim whitespace
        url=$(echo "$url" | xargs)
        ((total_urls++)) || true

        # Extract repository URL
        local repo_url
        repo_url=$(extract_repo_url "$url") || true

        if [[ -z "$repo_url" ]]; then
            ((skipped_invalid++)) || true
            continue
        fi

        # Get repo owner and name
        local repo_owner repo_name
        repo_owner=$(get_repo_owner "$url") || true
        repo_name=$(get_repo_name "$url") || true

        if [[ -z "$repo_name" ]]; then
            ((skipped_invalid++)) || true
            continue
        fi

        # Check for duplicates (by URL)
        if grep -qxF "$repo_url" "$processed_file" 2>/dev/null; then
            ((skipped_duplicate++)) || true
            continue
        fi
        echo "$repo_url" >> "$processed_file"

        # Check if already cloned
        local target_dir="$output_dir/$repo_name"
        if is_git_repo "$target_dir"; then
            ((skipped_existing++)) || true
            continue
        fi

        # Add to clone list: repo_url|repo_owner|repo_name|target_dir
        echo "${repo_url}|${repo_owner}|${repo_name}|${target_dir}" >> "$repos_file"

    done < "$links_file"

    local repos_to_clone
    repos_to_clone=$(wc -l < "$repos_file" | tr -d ' ')

    # ─────────────────────────────────────────────────────────────────────────
    # Phase 2: Display scan results
    # ─────────────────────────────────────────────────────────────────────────

    print_header "Git Clone with Rate Limiting"

    echo -e "  ${COLOR_BOLD}Links file:${COLOR_RESET}      $links_file"
    echo -e "  ${COLOR_BOLD}Output dir:${COLOR_RESET}      $output_dir"
    echo -e "  ${COLOR_BOLD}Delay:${COLOR_RESET}           ${delay}s between clones"
    $shallow && echo -e "  ${COLOR_BOLD}Mode:${COLOR_RESET}            shallow (--depth 1 --single-branch)"
    $dry_run && echo -e "  ${COLOR_YELLOW}${COLOR_BOLD}Dry run:${COLOR_RESET}         no actual cloning"
    echo ""
    separator
    echo -e "  ${COLOR_BOLD}Scan Results${COLOR_RESET}"
    separator
    echo -e "  Total URLs in file:    ${COLOR_BOLD}$total_urls${COLOR_RESET}"
    echo -e "  ${COLOR_GREEN}Repos to clone:${COLOR_RESET}      ${COLOR_BOLD}${COLOR_GREEN}$repos_to_clone${COLOR_RESET}"
    [[ $skipped_existing -gt 0 ]] && echo -e "  ${COLOR_YELLOW}Already cloned:${COLOR_RESET}      $skipped_existing"
    [[ $skipped_duplicate -gt 0 ]] && echo -e "  ${COLOR_YELLOW}Duplicates:${COLOR_RESET}          $skipped_duplicate"
    [[ $skipped_invalid -gt 0 ]] && echo -e "  ${COLOR_DIM}Invalid/non-git:${COLOR_RESET}     $skipped_invalid"
    echo ""

    # Nothing to clone?
    if [[ $repos_to_clone -eq 0 ]]; then
        info "Nothing to clone."
        return 0
    fi

    # Create output directory if needed
    if [[ ! -d "$output_dir" ]]; then
        if $dry_run; then
            info "Would create directory: $output_dir"
        else
            mkdir -p "$output_dir"
            $quiet || info "Created output directory: $output_dir"
        fi
    fi

    # ─────────────────────────────────────────────────────────────────────────
    # Phase 3: Clone repositories with per-repo progress
    # ─────────────────────────────────────────────────────────────────────────

    local current=0
    local cloned=0
    local failed=0
    local interrupted=false
    local current_repo=""
    local current_target=""

    # Signal handler for clean exit
    cleanup_and_exit() {
        interrupted=true
        echo ""
        echo ""
        warn "Interrupted! Cleaning up..."

        # Remove partially cloned repo if exists
        if [[ -n "$current_target" ]] && [[ -d "$current_target" ]] && ! is_git_repo "$current_target"; then
            dim "Removing incomplete clone: $current_target"
            rm -rf "$current_target"
        fi

        # Show partial summary
        echo ""
        separator
        echo -e "  ${COLOR_YELLOW}${COLOR_BOLD}Interrupted after $current of $repos_to_clone repos${COLOR_RESET}"
        separator
        echo -e "  ${COLOR_GREEN}Successfully cloned:${COLOR_RESET}   ${COLOR_BOLD}$cloned${COLOR_RESET}"
        [[ $failed -gt 0 ]] && echo -e "  ${COLOR_RED}Failed:${COLOR_RESET}                ${COLOR_BOLD}$failed${COLOR_RESET}"
        echo ""

        # Cleanup temp files
        rm -f "$processed_file" "$repos_file"
        exit 130
    }

    # Set up signal handlers
    trap cleanup_and_exit SIGINT SIGTERM

    separator
    echo -e "  ${COLOR_BOLD}Cloning${COLOR_RESET} (Ctrl+C to stop)"
    separator
    echo ""

    while IFS='|' read -r repo_url repo_owner repo_name target_dir; do
        # Check if interrupted
        $interrupted && break

        ((current++)) || true
        current_repo="$repo_name"
        current_target="$target_dir"

        # Build display name (owner/repo or just repo if no owner)
        local display_name="$repo_name"
        [[ -n "$repo_owner" ]] && display_name="${repo_owner}/${repo_name}"

        # Show which repo we're cloning
        echo -e "${COLOR_CYAN}[$current/$repos_to_clone]${COLOR_RESET} ${COLOR_BOLD}$display_name${COLOR_RESET}"

        if $dry_run; then
            dim "Would clone to: $target_dir"
            ((cloned++)) || true
        else
            # Perform the clone - output directly to terminal for real-time progress
            # No piping to avoid buffering issues with git's \r-based progress
            if git clone --single-branch --progress \
                $($shallow && echo "--depth 1") \
                "$repo_url" "$target_dir"; then
                success "Done: $display_name"
                ((cloned++)) || true
            else
                error "Failed: $display_name"
                ((failed++)) || true
            fi

            # Rate limiting delay (skip on last item)
            if [[ $current -lt $repos_to_clone ]]; then
                $quiet || dim "Waiting ${delay}s..."
                portable_sleep "$delay"
            fi
        fi

        echo ""

    done < "$repos_file"

    # Reset trap
    trap - SIGINT SIGTERM

    # ─────────────────────────────────────────────────────────────────────────
    # Phase 4: Summary
    # ─────────────────────────────────────────────────────────────────────────

    print_header "Summary"

    echo -e "  ${COLOR_GREEN}Successfully cloned:${COLOR_RESET}   ${COLOR_BOLD}$cloned${COLOR_RESET}"
    [[ $failed -gt 0 ]] && echo -e "  ${COLOR_RED}Failed:${COLOR_RESET}                ${COLOR_BOLD}$failed${COLOR_RESET}"
    [[ $skipped_existing -gt 0 ]] && echo -e "  ${COLOR_YELLOW}Already existed:${COLOR_RESET}       $skipped_existing"
    [[ $skipped_duplicate -gt 0 ]] && echo -e "  ${COLOR_YELLOW}Duplicates skipped:${COLOR_RESET}    $skipped_duplicate"
    [[ $skipped_invalid -gt 0 ]] && echo -e "  ${COLOR_DIM}Invalid URLs:${COLOR_RESET}          $skipped_invalid"
    echo ""

    # Return appropriate exit code
    [[ $failed -eq 0 ]]
}

#--------------------------------------------------------------------------------------------------
# Command: detect
#--------------------------------------------------------------------------------------------------

detect_usage() {
    echo -e "${COLOR_BOLD}Usage:${COLOR_RESET} $SCRIPT_NAME detect [options] <repos-dir>

Scan a directory of repositories and detect which can be converted to MCPB packages.

${COLOR_BOLD}Arguments:${COLOR_RESET}
  <repos-dir>           Directory containing repository subdirectories

${COLOR_BOLD}Options:${COLOR_RESET}
  -t, --threshold <n>   Minimum confidence % to consider convertible (default: 80)
  -l, --list            List all detected repos with details
  -o, --output <file>   Write results to TSV file
  -q, --quiet           Only show summary stats
  -h, --help            Show this help message

${COLOR_BOLD}Requires:${COLOR_RESET}
  tool-cli must be installed (https://github.com/anthropics/tool-cli)

${COLOR_BOLD}Examples:${COLOR_RESET}
  $SCRIPT_NAME detect ./repos
  $SCRIPT_NAME detect -t 90 --list ./repos
  $SCRIPT_NAME detect -o results.tsv ./repos
"
}

cmd_detect() {
    local repos_dir=""
    local threshold=80
    local list_all=false
    local output_file=""
    local quiet=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -t|--threshold)
                threshold="$2"
                shift 2
                ;;
            -l|--list)
                list_all=true
                shift
                ;;
            -o|--output)
                output_file="$2"
                shift 2
                ;;
            -q|--quiet)
                quiet=true
                shift
                ;;
            -h|--help)
                detect_usage
                return 0
                ;;
            -*)
                error "Unknown option: $1"
                detect_usage
                return 1
                ;;
            *)
                if [[ -z "$repos_dir" ]]; then
                    repos_dir="$1"
                else
                    error "Unexpected argument: $1"
                    detect_usage
                    return 1
                fi
                shift
                ;;
        esac
    done

    # Validate arguments
    if [[ -z "$repos_dir" ]]; then
        error "Missing required argument: <repos-dir>"
        echo ""
        detect_usage
        return 1
    fi

    if [[ ! -d "$repos_dir" ]]; then
        error "Directory not found: $repos_dir"
        return 1
    fi

    # Check if tool-cli is available
    if ! command -v tool &>/dev/null; then
        error "tool-cli is not installed"
        dim "Install it from: https://github.com/anthropics/tool-cli"
        return 1
    fi

    print_header "MCPB Package Detection"

    echo -e "  ${COLOR_BOLD}Repos dir:${COLOR_RESET}       $repos_dir"
    echo -e "  ${COLOR_BOLD}Threshold:${COLOR_RESET}       ${threshold}% confidence"
    echo ""

    # Stats counters
    local total=0
    local convertible=0
    local low_confidence=0
    local failed=0

    # Type counters (bash 3.x compatible)
    local count_nodejs=0
    local count_python=0
    local count_rust=0
    local count_binary=0
    local count_other=0

    # Transport counters
    local count_stdio=0
    local count_http=0

    # Results storage
    local results_file
    results_file=$(mktemp)
    trap "rm -f '$results_file'" EXIT

    # Write header to results
    echo -e "repo\ttype\ttransport\tentry\tconfidence\tbuild" >> "$results_file"

    separator
    echo -e "  ${COLOR_BOLD}Scanning${COLOR_RESET}"
    separator
    echo ""

    # Iterate through subdirectories
    for dir in "$repos_dir"/*/; do
        [[ ! -d "$dir" ]] && continue

        local repo_name
        repo_name=$(basename "$dir")
        ((total++)) || true

        $quiet || progress "Scanning: $repo_name"

        # Run tool detect
        local detect_output
        if detect_output=$(tool detect --concise --no-header "$dir" 2>/dev/null); then
            # Parse tab-separated output: type, transport, entry, confidence, build
            local type transport entry confidence build
            IFS=$'\t' read -r type transport entry confidence build <<< "$detect_output"

            # Remove % from confidence and convert to number
            local conf_num="${confidence%\%}"

            # Store result
            echo -e "${repo_name}\t${type}\t${transport}\t${entry}\t${confidence}\t${build}" >> "$results_file"

            # Update type counters
            case "$type" in
                Node.js|node) ((count_nodejs++)) || true ;;
                Python|python) ((count_python++)) || true ;;
                Rust|rust) ((count_rust++)) || true ;;
                Binary|binary) ((count_binary++)) || true ;;
                *) ((count_other++)) || true ;;
            esac

            # Update transport counters
            case "$transport" in
                stdio) ((count_stdio++)) || true ;;
                http) ((count_http++)) || true ;;
            esac

            # Check threshold
            if [[ "$conf_num" -ge "$threshold" ]]; then
                ((convertible++)) || true
                $quiet || success "$repo_name ${COLOR_DIM}(${type}, ${confidence})${COLOR_RESET}"
            else
                ((low_confidence++)) || true
                $quiet || warn "$repo_name ${COLOR_DIM}(${type}, ${confidence} - below threshold)${COLOR_RESET}"
            fi
        else
            ((failed++)) || true
            $quiet || error "$repo_name ${COLOR_DIM}(detection failed)${COLOR_RESET}"
        fi
    done

    echo ""

    # Write to output file if specified
    if [[ -n "$output_file" ]]; then
        cp "$results_file" "$output_file"
        info "Results written to: $output_file"
        echo ""
    fi

    # Show list if requested
    if $list_all && ! $quiet; then
        separator
        echo -e "  ${COLOR_BOLD}Convertible Repos${COLOR_RESET} (≥${threshold}% confidence)"
        separator
        echo ""
        echo -e "  ${COLOR_DIM}REPO\tTYPE\tTRANSPORT\tCONFIDENCE${COLOR_RESET}"
        tail -n +2 "$results_file" | while IFS=$'\t' read -r repo type transport entry confidence build; do
            local conf_num="${confidence%\%}"
            if [[ "$conf_num" -ge "$threshold" ]]; then
                printf "  %-30s %-10s %-8s %s\n" "$repo" "$type" "$transport" "$confidence"
            fi
        done
        echo ""
    fi

    # Summary
    print_header "Summary"

    echo -e "  ${COLOR_BOLD}Total scanned:${COLOR_RESET}       $total"
    echo -e "  ${COLOR_GREEN}Convertible:${COLOR_RESET}         ${COLOR_BOLD}$convertible${COLOR_RESET} (≥${threshold}%)"
    [[ $low_confidence -gt 0 ]] && echo -e "  ${COLOR_YELLOW}Low confidence:${COLOR_RESET}      $low_confidence (<${threshold}%)"
    [[ $failed -gt 0 ]] && echo -e "  ${COLOR_RED}Failed:${COLOR_RESET}              $failed"
    echo ""

    separator
    echo -e "  ${COLOR_BOLD}By Type${COLOR_RESET}"
    separator
    [[ $count_nodejs -gt 0 ]] && echo -e "  Node.js:           $count_nodejs"
    [[ $count_python -gt 0 ]] && echo -e "  Python:            $count_python"
    [[ $count_rust -gt 0 ]] && echo -e "  Rust:              $count_rust"
    [[ $count_binary -gt 0 ]] && echo -e "  Binary:            $count_binary"
    [[ $count_other -gt 0 ]] && echo -e "  Other:             $count_other"
    echo ""

    separator
    echo -e "  ${COLOR_BOLD}By Transport${COLOR_RESET}"
    separator
    [[ $count_stdio -gt 0 ]] && echo -e "  stdio:             $count_stdio"
    [[ $count_http -gt 0 ]] && echo -e "  http:              $count_http"
    echo ""
}

#--------------------------------------------------------------------------------------------------
# Command: convert
#--------------------------------------------------------------------------------------------------

convert_usage() {
    echo -e "${COLOR_BOLD}Usage:${COLOR_RESET} $SCRIPT_NAME convert [options] <repos-dir>

Convert repositories to MCPB packages using tool-cli.

Runs the full pipeline for each repo: detect → init → validate → build → info

${COLOR_BOLD}Arguments:${COLOR_RESET}
  <repos-dir>           Directory containing repository subdirectories

${COLOR_BOLD}Options:${COLOR_RESET}
  -t, --threshold <n>   Minimum confidence % to convert (default: 80)
  -i, --info-timeout <s> Timeout for 'tool info' in seconds (default: 30)
  -f, --force           Overwrite existing manifest.json files
  -n, --dry-run         Show what would be converted without converting
  -o, --output <file>   Write results to TSV file
  -q, --quiet           Minimal output (summary only)
  -h, --help            Show this help message

${COLOR_BOLD}Requires:${COLOR_RESET}
  tool-cli must be installed

${COLOR_BOLD}Examples:${COLOR_RESET}
  $SCRIPT_NAME convert ./repos
  $SCRIPT_NAME convert -t 90 -i 60 ./repos
  $SCRIPT_NAME convert --dry-run ./repos
  $SCRIPT_NAME convert -f -o results.tsv ./repos
"
}

cmd_convert() {
    local repos_dir=""
    local threshold=80
    local info_timeout=30
    local force=false
    local dry_run=false
    local output_file=""
    local quiet=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -t|--threshold)
                threshold="$2"
                shift 2
                ;;
            -i|--info-timeout)
                info_timeout="$2"
                shift 2
                ;;
            -f|--force)
                force=true
                shift
                ;;
            -n|--dry-run)
                dry_run=true
                shift
                ;;
            -o|--output)
                output_file="$2"
                shift 2
                ;;
            -q|--quiet)
                quiet=true
                shift
                ;;
            -h|--help)
                convert_usage
                return 0
                ;;
            -*)
                error "Unknown option: $1"
                convert_usage
                return 1
                ;;
            *)
                if [[ -z "$repos_dir" ]]; then
                    repos_dir="$1"
                else
                    error "Unexpected argument: $1"
                    convert_usage
                    return 1
                fi
                shift
                ;;
        esac
    done

    # Validate arguments
    if [[ -z "$repos_dir" ]]; then
        error "Missing required argument: <repos-dir>"
        echo ""
        convert_usage
        return 1
    fi

    if [[ ! -d "$repos_dir" ]]; then
        error "Directory not found: $repos_dir"
        return 1
    fi

    # Check if tool-cli is available
    if ! command -v tool &>/dev/null; then
        error "tool-cli is not installed"
        dim "Install it from: https://github.com/anthropics/tool-cli"
        return 1
    fi

    print_header "MCPB Package Conversion"

    echo -e "  ${COLOR_BOLD}Repos dir:${COLOR_RESET}       $repos_dir"
    echo -e "  ${COLOR_BOLD}Threshold:${COLOR_RESET}       ${threshold}% confidence"
    echo -e "  ${COLOR_BOLD}Info timeout:${COLOR_RESET}    ${info_timeout}s"
    echo -e "  ${COLOR_BOLD}Force:${COLOR_RESET}           $($force && echo "yes" || echo "no")"
    $dry_run && echo -e "  ${COLOR_YELLOW}${COLOR_BOLD}Dry run:${COLOR_RESET}         no actual conversion"
    echo ""

    # Stage stats counters
    local total=0
    local stage_detect_ok=0
    local stage_detect_fail=0
    local stage_detect_low=0
    local stage_init_ok=0
    local stage_init_fail=0
    local stage_init_skip=0
    local stage_validate_ok=0
    local stage_validate_fail=0
    local stage_build_ok=0
    local stage_build_fail=0
    local stage_build_skip=0
    local stage_info_ok=0
    local stage_info_fail=0

    # Fully working counter
    local fully_working=0

    # Results storage
    local results_file
    results_file=$(mktemp)
    trap "rm -f '$results_file'" EXIT

    echo -e "repo\tdetect\tinit\tvalidate\tbuild\tinfo\ttype\tconfidence\ttools\tprompts\tresources" >> "$results_file"

    separator
    echo -e "  ${COLOR_BOLD}Converting${COLOR_RESET} (detect → init → validate → build → info)"
    separator
    echo ""

    # Count total repos first
    local total_repos=0
    for dir in "$repos_dir"/*/; do
        [[ -d "$dir" ]] && ((total_repos++)) || true
    done

    # Iterate through subdirectories
    local current=0
    for dir in "$repos_dir"/*/; do
        [[ ! -d "$dir" ]] && continue

        local repo_name
        repo_name=$(basename "$dir")
        ((current++)) || true
        ((total++)) || true

        # Per-repo status tracking
        local status_detect="-"
        local status_init="-"
        local status_validate="-"
        local status_build="-"
        local status_info="-"
        local detected_type="-"
        local detected_confidence="-"
        local info_tools="-"
        local info_prompts="-"
        local info_resources="-"

        # Print repo header
        $quiet || echo -e "${COLOR_CYAN}[${current}/${total_repos}]${COLOR_RESET} ${COLOR_BOLD}${repo_name}${COLOR_RESET}"

        # ─────────────────────────────────────────────────────────────────────
        # Stage 1: Detect
        # ─────────────────────────────────────────────────────────────────────
        local detect_output detect_err
        if detect_output=$(tool detect --concise --no-header "$dir" 2>&1); then
            # Parse detection output: type, transport, entry, confidence, build
            local type transport entry confidence build_cmd
            IFS=$'\t' read -r type transport entry confidence build_cmd <<< "$detect_output"
            local conf_num="${confidence%\%}"
            detected_type="$type"
            detected_confidence="$confidence"

            # Check threshold
            if [[ "$conf_num" -lt "$threshold" ]]; then
                status_detect="low"
                ((stage_detect_low++)) || true
                $quiet || echo -e "  ├─ detect:    ${COLOR_YELLOW}${type}, ${transport}, ${confidence} (below ${threshold}%)${COLOR_RESET}"
                $quiet || echo ""
                echo -e "${repo_name}\t${status_detect}\t-\t-\t-\t-\t${type}\t${confidence}\t-\t-\t-" >> "$results_file"
                continue
            fi

            status_detect="ok"
            ((stage_detect_ok++)) || true
            $quiet || echo -e "  ├─ detect:    ${COLOR_GREEN}${type}, ${transport}, ${confidence}${COLOR_RESET}"
        else
            detect_err=$(echo "$detect_output" | grep -iE "error|not found|failed" | head -1 | sed 's/^[[:space:]]*//' | cut -c1-50 || true)
            [[ -z "$detect_err" ]] && detect_err="detection failed"
            status_detect="fail"
            ((stage_detect_fail++)) || true
            $quiet || echo -e "  └─ detect:    ${COLOR_RED}failed${COLOR_RESET} ${COLOR_DIM}(${detect_err})${COLOR_RESET}"
            $quiet || echo ""
            echo -e "${repo_name}\t${status_detect}\t-\t-\t-\t-\t-\t-\t-\t-\t-" >> "$results_file"
            continue
        fi

        # ─────────────────────────────────────────────────────────────────────
        # Stage 2: Init
        # ─────────────────────────────────────────────────────────────────────
        local manifest_exists=false
        [[ -f "$dir/manifest.json" ]] && manifest_exists=true

        if $manifest_exists && ! $force; then
            status_init="skip"
            ((stage_init_skip++)) || true
            $quiet || echo -e "  ├─ init:      ${COLOR_YELLOW}skipped (exists, use -f)${COLOR_RESET}"
        elif $dry_run; then
            local action="create"
            $manifest_exists && action="overwrite"
            status_init="dry"
            $quiet || echo -e "  ├─ init:      ${COLOR_CYAN}would ${action}${COLOR_RESET}"
        else
            local init_flags="-y"
            $force && init_flags="$init_flags -f"

            local init_output
            if init_output=$(tool init $init_flags "$dir" 2>&1); then
                status_init="ok"
                ((stage_init_ok++)) || true
                local action="created"
                $manifest_exists && action="overwrote"
                $quiet || echo -e "  ├─ init:      ${COLOR_GREEN}${action} manifest.json${COLOR_RESET}"
            else
                local init_err
                init_err=$(echo "$init_output" | grep -iE "error|failed|cannot" | head -1 | sed 's/^[[:space:]]*//' | cut -c1-50 || true)
                [[ -z "$init_err" ]] && init_err="init failed"
                status_init="fail"
                ((stage_init_fail++)) || true
                $quiet || echo -e "  └─ init:      ${COLOR_RED}failed${COLOR_RESET} ${COLOR_DIM}(${init_err})${COLOR_RESET}"
                $quiet || echo ""
                echo -e "${repo_name}\t${status_detect}\t${status_init}\t-\t-\t-\t${detected_type}\t${detected_confidence}\t-\t-\t-" >> "$results_file"
                continue
            fi
        fi

        # Skip remaining stages only if dry run
        if $dry_run; then
            $quiet || echo ""
            echo -e "${repo_name}\t${status_detect}\t${status_init}\t-\t-\t-\t${detected_type}\t${detected_confidence}\t-\t-\t-" >> "$results_file"
            continue
        fi

        # ─────────────────────────────────────────────────────────────────────
        # Stage 3: Validate
        # ─────────────────────────────────────────────────────────────────────
        local validate_output
        if validate_output=$(tool validate --quiet "$dir" 2>&1); then
            status_validate="ok"
            ((stage_validate_ok++)) || true
            $quiet || echo -e "  ├─ validate:  ${COLOR_GREEN}valid${COLOR_RESET}"
        else
            status_validate="fail"
            ((stage_validate_fail++)) || true
            local validate_err
            # Try to extract error code like error[missing_field]
            validate_err=$(echo "$validate_output" | grep -oE "error\[[^\]]+\]" | head -1 || true)
            # If no error code, try to get a message
            if [[ -z "$validate_err" ]]; then
                validate_err=$(echo "$validate_output" | grep -iE "error|invalid|missing" | head -1 | sed 's/^[[:space:]]*//' | cut -c1-40 || true)
            fi
            [[ -z "$validate_err" ]] && validate_err="invalid"
            $quiet || echo -e "  ├─ validate:  ${COLOR_RED}failed${COLOR_RESET} ${COLOR_DIM}(${validate_err})${COLOR_RESET}"
        fi

        # ─────────────────────────────────────────────────────────────────────
        # Stage 4: Build
        # ─────────────────────────────────────────────────────────────────────
        # Check if build script exists in manifest's _meta.store.tool.mcpb.scripts
        local has_build_script=false
        if [[ -f "$dir/manifest.json" ]]; then
            if grep -q '"scripts"' "$dir/manifest.json" 2>/dev/null && \
               grep -q '"build"' "$dir/manifest.json" 2>/dev/null; then
                has_build_script=true
            fi
        fi

        if $has_build_script; then
            local build_output
            if build_output=$(tool build "$dir" 2>&1); then
                status_build="ok"
                ((stage_build_ok++)) || true
                $quiet || echo -e "  ├─ build:     ${COLOR_GREEN}success${COLOR_RESET}"
            else
                local build_err
                # Try to get meaningful error from npm/pip/cargo etc
                build_err=$(echo "$build_output" | grep -iE "error|ERR!|failed|cannot find|not found" | head -1 | sed 's/^[[:space:]]*//' | cut -c1-50 || true)
                [[ -z "$build_err" ]] && build_err="build failed"
                status_build="fail"
                ((stage_build_fail++)) || true
                $quiet || echo -e "  ├─ build:     ${COLOR_RED}failed${COLOR_RESET} ${COLOR_DIM}(${build_err})${COLOR_RESET}"
            fi
        else
            status_build="skip"
            ((stage_build_skip++)) || true
            $quiet || echo -e "  ├─ build:     ${COLOR_DIM}skipped (no build script)${COLOR_RESET}"
        fi

        # ─────────────────────────────────────────────────────────────────────
        # Stage 5: Info (the real test)
        # ─────────────────────────────────────────────────────────────────────
        local info_output
        if info_output=$(timeout "${info_timeout}s" tool info --concise "$dir" 2>&1); then
            # Parse concise output format:
            # - Tools: lines with pattern "toolset:name(" after #tool header
            # - Prompts: lines with pattern "toolset:name\t" after #prompt header
            # - Resources: lines starting with URI (not #) after #uri header

            # Count tools (lines containing "(" that aren't headers)
            info_tools=$(echo "$info_output" | grep -c '(' 2>/dev/null) || info_tools="0"

            # Count prompts (lines with tab after #prompt section, excluding headers)
            info_prompts=$(echo "$info_output" | grep -E '^[^#].*\t"' 2>/dev/null | grep -v '^[a-z]+\t' 2>/dev/null | wc -l | tr -d ' ') || info_prompts="0"
            # Simpler: count lines between #prompt and next # or EOF
            local in_prompts=false
            local prompt_count=0
            while IFS= read -r line; do
                if [[ "$line" == "#prompt"* ]]; then
                    in_prompts=true
                    continue
                elif [[ "$line" == "#"* ]]; then
                    in_prompts=false
                elif $in_prompts && [[ -n "$line" ]]; then
                    ((prompt_count++)) || true
                fi
            done <<< "$info_output"
            info_prompts="$prompt_count"

            # Count resources (lines between #uri and next # or EOF)
            local in_resources=false
            local resource_count=0
            while IFS= read -r line; do
                if [[ "$line" == "#uri"* ]]; then
                    in_resources=true
                    continue
                elif [[ "$line" == "#"* ]]; then
                    in_resources=false
                elif $in_resources && [[ -n "$line" ]]; then
                    ((resource_count++)) || true
                fi
            done <<< "$info_output"
            info_resources="$resource_count"

            status_info="ok"
            ((stage_info_ok++)) || true
            $quiet || echo -e "  └─ info:      ${COLOR_GREEN}${info_tools} tools, ${info_prompts} prompts, ${info_resources} resources${COLOR_RESET}"

            # Count as fully working if validate passed and info succeeded
            if [[ "$status_validate" == "ok" ]]; then
                ((fully_working++)) || true
            fi
        else
            local exit_code=$?
            status_info="fail"
            ((stage_info_fail++)) || true
            if [[ $exit_code -eq 124 ]]; then
                $quiet || echo -e "  └─ info:      ${COLOR_RED}failed${COLOR_RESET} ${COLOR_DIM}(timeout after ${info_timeout}s)${COLOR_RESET}"
            else
                local info_err
                info_err=$(echo "$info_output" | grep -iE "error|failed|refused|not found|ENOENT|ECONNREFUSED" | head -1 | sed 's/^[[:space:]]*//' | cut -c1-50 || true)
                [[ -z "$info_err" ]] && info_err="server failed to start"
                $quiet || echo -e "  └─ info:      ${COLOR_RED}failed${COLOR_RESET} ${COLOR_DIM}(${info_err})${COLOR_RESET}"
            fi
        fi

        $quiet || echo ""

        # Write results
        echo -e "${repo_name}\t${status_detect}\t${status_init}\t${status_validate}\t${status_build}\t${status_info}\t${detected_type}\t${detected_confidence}\t${info_tools}\t${info_prompts}\t${info_resources}" >> "$results_file"

    done

    # Write to output file if specified
    if [[ -n "$output_file" ]]; then
        cp "$results_file" "$output_file"
        info "Results written to: $output_file"
        echo ""
    fi

    # Summary
    print_header "Summary"

    echo -e "  ${COLOR_BOLD}Total scanned:${COLOR_RESET}       $total"
    echo -e "  ${COLOR_GREEN}${COLOR_BOLD}Fully working:${COLOR_RESET}       ${COLOR_BOLD}$fully_working${COLOR_RESET} ${COLOR_DIM}(validate + info passed)${COLOR_RESET}"
    echo ""

    separator
    echo -e "  ${COLOR_BOLD}By Stage${COLOR_RESET}"
    separator
    echo ""
    printf "  %-12s ${COLOR_GREEN}%3d ok${COLOR_RESET}  ${COLOR_RED}%3d fail${COLOR_RESET}  ${COLOR_YELLOW}%3d low${COLOR_RESET}\n" "detect:" "$stage_detect_ok" "$stage_detect_fail" "$stage_detect_low"
    printf "  %-12s ${COLOR_GREEN}%3d ok${COLOR_RESET}  ${COLOR_RED}%3d fail${COLOR_RESET}  ${COLOR_YELLOW}%3d skip${COLOR_RESET}\n" "init:" "$stage_init_ok" "$stage_init_fail" "$stage_init_skip"
    printf "  %-12s ${COLOR_GREEN}%3d ok${COLOR_RESET}  ${COLOR_RED}%3d fail${COLOR_RESET}\n" "validate:" "$stage_validate_ok" "$stage_validate_fail"
    printf "  %-12s ${COLOR_GREEN}%3d ok${COLOR_RESET}  ${COLOR_RED}%3d fail${COLOR_RESET}  ${COLOR_DIM}%3d skip${COLOR_RESET}\n" "build:" "$stage_build_ok" "$stage_build_fail" "$stage_build_skip"
    printf "  %-12s ${COLOR_GREEN}%3d ok${COLOR_RESET}  ${COLOR_RED}%3d fail${COLOR_RESET}\n" "info:" "$stage_info_ok" "$stage_info_fail"
    echo ""
}

#--------------------------------------------------------------------------------------------------
# Command: help
#--------------------------------------------------------------------------------------------------

show_help() {
    echo -e "${COLOR_BOLD}${SCRIPT_NAME}${COLOR_RESET} - Multi-Utility Script v${VERSION}

A collection of useful command-line utilities with friendly output.
Compatible with macOS (Darwin) and Linux.

${COLOR_BOLD}Usage:${COLOR_RESET}
  $SCRIPT_NAME <command> [options]

${COLOR_BOLD}Commands:${COLOR_RESET}
  clone       Clone git repositories from a list with rate limiting
  detect      Detect MCPB-convertible repos in a directory
  convert     Convert repos to MCPB packages
  help        Show this help message
  version     Show version information

${COLOR_BOLD}Examples:${COLOR_RESET}
  $SCRIPT_NAME clone links.txt
  $SCRIPT_NAME detect ./repos
  $SCRIPT_NAME convert ./repos
  $SCRIPT_NAME help

Run '${COLOR_BOLD}$SCRIPT_NAME <command> --help${COLOR_RESET}' for command-specific help.
"
}

show_version() {
    echo -e "${COLOR_BOLD}$SCRIPT_NAME${COLOR_RESET} v${VERSION}"
}

#--------------------------------------------------------------------------------------------------
# Main Entry Point
#--------------------------------------------------------------------------------------------------

main() {
    # No arguments - show help
    if [[ $# -eq 0 ]]; then
        show_help
        return 0
    fi

    local command="$1"
    shift

    case "$command" in
        clone)
            cmd_clone "$@"
            ;;
        detect)
            cmd_detect "$@"
            ;;
        convert)
            cmd_convert "$@"
            ;;
        help|--help|-h)
            show_help
            ;;
        version|--version|-v)
            show_version
            ;;
        *)
            error "Unknown command: $command"
            echo ""
            show_help
            return 1
            ;;
    esac
}

# Run main function
main "$@"
